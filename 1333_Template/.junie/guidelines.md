# Project Guidelines for RTS Game Development

## Project Overview
This is an RTS (Real-Time Strategy) project designed for students to demonstrate good Object-Oriented Programming (OOP) principles while learning algorithms and advanced game programming concepts. The project serves as a practical application of theoretical knowledge in a game development context.

## Code Quality Requirements
- **Clean and Readable**: Code should be well-organized, following consistent naming conventions and formatting
- **Thoroughly Commented**: Every line of code should be commented to explain its purpose and functionality
- **Efficient Implementation**: Solutions should prioritize efficiency in both time and space complexity
- **OOP Principles**: Code must demonstrate optimized use of:
  - **Encapsulation**: Properly hide implementation details and expose only necessary interfaces
  - **Abstraction**: Create appropriate abstractions to manage complexity
  - **Inheritance**: Use inheritance hierarchies effectively where appropriate
  - **Polymorphism**: Implement polymorphic behavior to create flexible and extensible systems

## Project Structure
The project follows a standard Unity structure with the main RTS components located in:
- `Assets/1333_RTS/StudentWork/Scripts/`: Contains all C# scripts for game functionality
  - Key components include GridManager, GameManager, Pathfinder, UnitManager, etc.
- `Assets/1333_RTS/StudentWork/ScriptableObjects/`: Contains Unity ScriptableObjects for configuration
  - Includes terrain types, grid settings, and other game parameters

## Learning Objectives
Students working on this project will gain experience with:
1. Implementing pathfinding algorithms (A*, Dijkstra's, etc.)
2. Managing game state and object lifecycles
3. Creating efficient grid-based systems
4. Developing unit selection and movement mechanics
5. Applying OOP principles in a practical game development context

## Evaluation Criteria
Solutions will be evaluated based on:
- Correctness of implementation
- Code quality and adherence to OOP principles
- Performance optimization
- Documentation quality
- Creative problem-solving approaches